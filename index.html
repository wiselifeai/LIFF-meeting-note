<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiseLife æœƒè­°åŠ©ç† v5.2 JWT (Fixed)</title>
    <script charset="utf-8" src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
    <style>
        :root { --primary: #00B900; --processing: #3498db; --warning: #f39c12; --debug: #9b59b6; }
        body { font-family: "Microsoft JhengHei", sans-serif; padding: 20px; background-color: #f4f6f9; color: #333; }
        .container { background: white; padding: 30px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); max-width: 500px; margin: 0 auto; position: relative; }
        
        .version-tag { position: absolute; top: 15px; right: 15px; font-size: 0.75rem; color: white; background: var(--debug); padding: 4px 8px; border-radius: 4px; }
        h2 { color: #2c3e50; text-align: center; margin-bottom: 25px; font-weight: 700; }

        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; color: #555; font-weight: bold; }
        .sub-label { font-size: 0.8em; color: #888; font-weight: normal; margin-left: 5px; }

        input[type="text"], input[type="email"], input[type="file"] { 
            width: 100%; padding: 12px; border: 2px solid #eef2f7; border-radius: 10px; box-sizing: border-box; font-size: 16px; transition: all 0.3s;
        }
        input:focus { border-color: var(--primary); background: #fff; outline: none; }
        
        .file-info { 
            margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 8px; 
            font-size: 0.85rem; color: #666; display: none;
        }
        .file-info.large-file { background: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
        
        button { 
            width: 100%; background: linear-gradient(135deg, #00B900 0%, #009900 100%); color: white; border: none; padding: 16px; 
            margin-top: 10px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; 
            box-shadow: 0 4px 15px rgba(0,185,0,0.3); transition: transform 0.2s;
        }
        button:disabled { background: #ccc; cursor: not-allowed; box-shadow: none; transform: none; }
        button.close-btn { background: #7f8c8d; margin-top: 10px; display: none; }

        .progress-wrapper { margin-top: 25px; display: none; }
        .progress-container { width: 100%; background-color: #f1f1f1; border-radius: 10px; overflow: hidden; height: 12px; }
        .progress-bar { width: 0%; height: 100%; background-color: var(--primary); border-radius: 10px; transition: width 0.3s ease; }
        
        .progress-bar.processing {
            width: 100% !important; background-color: var(--processing);
            background-image: linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);
            background-size: 1rem 1rem; animation: progress-bar-stripes 1s linear infinite;
        }
        @keyframes progress-bar-stripes { from { background-position: 1rem 0; } to { background-position: 0 0; } }

        .status-text { text-align: center; margin-top: 10px; font-size: 0.9rem; color: #666; font-weight: bold; }
        
        .message-box { margin-top: 20px; padding: 15px; border-radius: 8px; text-align: center; display: none; }
        .success { background: #e3fdf5; color: #00b894; border: 1px solid #ccfbf1; }
        .error { background: #ffebeb; color: #d63031; border: 1px solid #ffcccc; }

        .debug-panel {
            margin-top: 20px; padding: 15px; background: #2c3e50; border-radius: 8px;
            color: #ecf0f1; font-family: 'Courier New', monospace; font-size: 0.75rem;
            max-height: 250px; overflow-y: auto;
        }
        .debug-panel h4 { margin: 0 0 10px 0; color: #9b59b6; font-size: 0.85rem; }
        .debug-line { margin: 3px 0; padding: 3px 5px; border-left: 3px solid #3498db; background: rgba(52, 152, 219, 0.1); }
        .debug-line.error { border-left-color: #e74c3c; background: rgba(231, 76, 60, 0.1); }
        .debug-line.success { border-left-color: #2ecc71; background: rgba(46, 204, 113, 0.1); }
        .debug-line.warn { border-left-color: #f39c12; background: rgba(243, 156, 18, 0.1); }
    </style>
</head>
<body>
    <div class="container">
        <div class="version-tag">ğŸ” v5.3 JWT (Fixed)</div>

        <h2>ğŸ™ï¸ WiseLife æœƒè­°åŠ©ç†</h2>
        <form id="uploadForm">
            <div class="form-group">
                <label>1. æª”æ¡ˆä¸Šå‚³ <span class="sub-label">(æ–‡ä»¶/éŒ„éŸ³)</span></label>
                <input type="file" id="fileInput" name="file" 
                       accept="audio/*,text/plain,.m4a,.mp3,.wav,.txt,.md,.pdf,.doc,.docx,.xls,.xlsx,.csv" required>
                <small style="color:#aaa; display:block; margin-top:5px;">ğŸ“‚ æ”¯æ´ M4A, MP3, WAV, PDF, Word, Excel</small>
                <div id="fileInfo" class="file-info"></div>
            </div>
            
            <div class="form-group">
                <label>2. æ¥æ”¶ Email <span class="sub-label">(é¸å¡«ï¼Œæœªå¡«å¯«å°‡é€é LINE é€šçŸ¥)</span></label>
                <input type="email" id="emailInput" name="email" placeholder="è¼¸å…¥ Email ä»¥æ¥æ”¶å®Œæ•´ PDF å ±å‘Šï¼ˆé¸å¡«ï¼‰">
            </div>

            <button type="submit" id="submitBtn">ğŸš€ é–‹å§‹æ™ºæ…§åˆ†æ</button>
            <button type="button" id="closeBtn" class="close-btn" onclick="liff.closeWindow()">âŒ é—œé–‰è¦–çª—</button>
        </form>

        <div class="progress-wrapper" id="progressWrapper">
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="status-text" id="statusText">æº–å‚™ä¸­...</div>
        </div>

        <div id="resultMsg" class="message-box"></div>
        <div class="debug-panel" id="debugPanel">
            <h4>ğŸ” Debug Console</h4>
            <div id="debugLog"></div>
        </div>
    </div>

    <script>
        // ==========================================
        // âš™ï¸ è¨­å®šå€ - v5.2 JWT Token Integration
        // ==========================================
        const LIFF_ID = "2008799993-Dq2SOrHq"; 
        const N8N_WEBHOOK_URL = "https://https://wiselife.zeabur.app/webhook/process-meeting";
        const N8N_TOKEN_URL = "https://https://wiselife.zeabur.app/webhook/get-temp-token";
        
        const GROQ_LIMIT = 25 * 1024 * 1024; // 25MB (Groq Whisper é™åˆ¶)
        const LARGE_FILE_THRESHOLD = 24 * 1024 * 1024; // 24MB
        const AUDIO_CHUNK_DURATION = 180; // 3 åˆ†é˜
        
        // ==========================================
        // ğŸ”‘ JWT Token ç®¡ç†
        // ==========================================
        let TEMP_GROQ_TOKEN = null;
        let TOKEN_EXPIRES_AT = null;
        let TOKEN_USAGE_COUNT = 0;

        async function getTemporaryToken() {
            try {
                debugLog('ğŸ”‘ è«‹æ±‚è‡¨æ™‚ Groq Token...', 'info');
                
                const userId = await getUserId();
                const response = await fetch(N8N_TOKEN_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: userId,
                        deviceInfo: navigator.userAgent
                    })
                });
                
                if (!response.ok) {
                    throw new Error('ç„¡æ³•å–å¾—è‡¨æ™‚ Token');
                }
                
                const data = await response.json();
                
                TEMP_GROQ_TOKEN = data.token;
                TOKEN_EXPIRES_AT = new Date(data.expiresAt);
                TOKEN_USAGE_COUNT = 0;
                
                debugLog(`âœ… Token å·²å–å¾—ï¼Œæœ‰æ•ˆè‡³ ${TOKEN_EXPIRES_AT.toLocaleTimeString()}`, 'success');
                
            } catch (error) {
                debugLog(`âŒ Token å–å¾—å¤±æ•—: ${error.message}`, 'error');
                throw error;
            }
        }

        async function ensureValidToken() {
            const now = new Date();
            
            // æª¢æŸ¥æ˜¯å¦éœ€è¦é‡æ–°å–å¾—
            if (!TEMP_GROQ_TOKEN || now >= TOKEN_EXPIRES_AT || TOKEN_USAGE_COUNT >= 18) {
                if (TOKEN_USAGE_COUNT >= 18) {
                    debugLog('âš ï¸ Token ä½¿ç”¨æ¬¡æ•¸æ¥è¿‘ä¸Šé™ï¼Œé‡æ–°å–å¾—...', 'warn');
                }
                await getTemporaryToken();
            }
        }

        async function transcribeWithGroq(audioFile) {
            await ensureValidToken();
            
            TOKEN_USAGE_COUNT++;
            debugLog(`ğŸ“¤ å‘¼å« Groq API (ä½¿ç”¨æ¬¡æ•¸: ${TOKEN_USAGE_COUNT}/20)`, 'info');
            
            const formData = new FormData();
            formData.append('file', audioFile, 'audio.wav');
            formData.append('model', 'whisper-large-v3-turbo');
            formData.append('language', 'zh');
            formData.append('response_format', 'json');
            
            const response = await fetch('https://api.groq.com/openai/v1/audio/transcriptions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${TEMP_GROQ_TOKEN}`
                },
                body: formData
            });
            
            if (!response.ok) {
                // Token å¤±æ•ˆï¼Œé‡è©¦ä¸€æ¬¡
                if (response.status === 401) {
                    debugLog('âš ï¸ Token ç„¡æ•ˆï¼Œé‡æ–°å–å¾—å¾Œé‡è©¦...', 'warn');
                    await getTemporaryToken();
                    return transcribeWithGroq(audioFile);
                }
                
                const error = await response.json();
                throw new Error(error.error?.message || 'Groq è½‰éŒ„å¤±æ•—');
            }
            
            const result = await response.json();
            return result.text;
        }

        // ==========================================
        // ğŸµ éŸ³è¨Šè™•ç†å‡½æ•¸ - JWT Token æ¨¡å¼
        // ==========================================
        
        async function processSmallAudioWithJWT(file, email) {
            setupUI("ğŸ¤ æ­£åœ¨è½‰éŒ„ï¼ˆJWT æ¨¡å¼ï¼‰...");
            
            try {
                const transcript = await transcribeWithGroq(file);
                
                debugLog(`âœ… è½‰éŒ„å®Œæˆï¼Œå…± ${transcript.length} å­—`, 'success');
                
                await sendTranscriptToN8N({
                    uploadType: 'transcript_only',
                    transcript: transcript,
                    fileName: file.name,
                    email: email || '',
                    userId: await getUserId(),
                    fileSize: file.size,
                    processingMode: 'jwt_direct'
                });
                
                handleFinalSuccess();
                
            } catch (error) {
                showError(`è½‰éŒ„å¤±æ•—: ${error.message}`);
            }
        }

        async function processLargeAudioWithJWT(file, email) {
            setupUI("ğŸ§ æ­£åœ¨è™•ç†å¤§å‹éŸ³è¨Šï¼ˆJWT æ¨¡å¼ï¼‰...");
            
            try {
                // æ­¥é©Ÿ 1: è§£ç¢¼éŸ³è¨Š
                debugLog('ğŸ“€ è§£ç¢¼éŸ³è¨Šæª”æ¡ˆ...', 'info');
                const arrayBuffer = await file.arrayBuffer();
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                
                const totalDuration = audioBuffer.duration;
                const totalChunks = Math.ceil(totalDuration / AUDIO_CHUNK_DURATION);
                
                debugLog(`ğŸµ éŸ³è¨Šé•·åº¦ ${totalDuration.toFixed(1)}ç§’ï¼Œåˆ†æˆ ${totalChunks} æ®µ`, 'info');
                
                // æ­¥é©Ÿ 2: é€æ®µè½‰éŒ„
                const transcripts = [];
                
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * AUDIO_CHUNK_DURATION;
                    const end = Math.min(start + AUDIO_CHUNK_DURATION, totalDuration);
                    
                    updateProgress(i + 1, totalChunks, `è½‰éŒ„ç¬¬ ${i + 1}/${totalChunks} æ®µ`);
                    
                    // åˆ‡å‰²éŸ³è¨Š
                    debugLog(`âœ‚ï¸ åˆ‡å‰²ç¬¬ ${i + 1} æ®µ (${start.toFixed(1)}s - ${end.toFixed(1)}s)`, 'info');
                    const chunkBlob = await sliceAndEncodeWav(audioBuffer, start, end);
                    
                    // ä½¿ç”¨ JWT Token è½‰éŒ„
                    const transcript = await transcribeWithGroq(chunkBlob);
                    
                    transcripts.push(transcript);
                    debugLog(`âœ… ç¬¬ ${i + 1} æ®µå®Œæˆ: ${transcript.substring(0, 30)}...`, 'success');
                }
                
                // æ­¥é©Ÿ 3: åˆä½µæ–‡å­—
                const fullTranscript = transcripts.join('\n\n');
                
                debugLog(`ğŸ‰ æ‰€æœ‰æ®µè½è½‰éŒ„å®Œæˆï¼Œç¸½å…± ${fullTranscript.length} å­—`, 'success');
                
                // æ­¥é©Ÿ 4: ç™¼é€æ–‡å­—è‡³ N8N
                await sendTranscriptToN8N({
                    uploadType: 'transcript_only',
                    transcript: fullTranscript,
                    fileName: file.name,
                    email: email || '',
                    userId: await getUserId(),
                    fileSize: file.size,
                    processingMode: 'jwt_chunked',
                    totalChunks: totalChunks
                });
                
                handleFinalSuccess();
                
            } catch (error) {
                showError(`è™•ç†å¤±æ•—: ${error.message}`);
            }
        }

        async function sendTranscriptToN8N(payload) {
            // ==========================================
            // [Fix] ç§»é™¤å¤šé¤˜çš„ { body: ... } åŒ…è£
            // ==========================================
            const response = await fetch(N8N_WEBHOOK_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload) // ä¿®æ­£è™•ï¼šç›´æ¥å‚³é€ payload
            });
            
            if (!response.ok) {
                throw new Error(`N8N å›æ‡‰éŒ¯èª¤: ${response.status}`);
            }
            
            return await response.json();
        }

        // ==========================================
        // ğŸ“„ ééŸ³è¨Šæª”æ¡ˆè™•ç†ï¼ˆä¿ç•™åŸæœ‰é‚è¼¯ï¼‰
        // ==========================================
        
        function uploadDirectly(file, email) {
            setupUI("â³ ä¸Šå‚³ä¸­...");
            const formData = new FormData();
            formData.append('file', file);
            formData.append('email', email || '');
            formData.append('uploadType', 'direct');
            
            appendUserId(formData).then(() => {
                const xhr = new XMLHttpRequest();
                xhr.open('POST', N8N_WEBHOOK_URL, true);
                
                xhr.upload.onprogress = function(e) {
                    if (e.lengthComputable) updateProgress(e.loaded, e.total, "ğŸ“¤ ä¸Šå‚³ä¸­...");
                };

                xhr.onload = () => handleXhrLoad(xhr);
                xhr.onerror = () => showError("ç¶²è·¯éŒ¯èª¤");
                xhr.send(formData);
            });
        }

        async function uploadLargeFile(file, email) {
            setupUI("â³ æ–‡ä»¶åˆ†æ®µè™•ç†ä¸­...");
            const progressBar = document.getElementById('progressBar');
            const statusText = document.getElementById('statusText');
            const SAFE_CHUNK_SIZE = 10 * 1024 * 1024;

            const totalChunks = Math.ceil(file.size / SAFE_CHUNK_SIZE);
            const sessionId = `s_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
            
            debugLog(`ğŸ“¦ æ–‡ä»¶åˆ†æ®µ: ${totalChunks} æ®µ`, 'info');

            try {
                let userId = await getUserId();

                for (let i = 0; i < totalChunks; i++) {
                    const start = i * SAFE_CHUNK_SIZE;
                    const end = Math.min(start + SAFE_CHUNK_SIZE, file.size);
                    const chunk = file.slice(start, end);

                    statusText.textContent = `ğŸ“¤ ä¸Šå‚³åˆ†æ®µ ${i + 1}/${totalChunks}...`;
                    const percent = Math.round(((i + 1) / totalChunks) * 100);
                    progressBar.style.width = percent + "%";

                    const base64Chunk = await blobToBase64(chunk);

                    await uploadChunkJson(
                        {
                            uploadType: 'chunked',
                            sessionId: sessionId,
                            chunkIndex: i,
                            totalChunks: totalChunks,
                            chunkData: base64Chunk,
                            fileName: file.name,
                            mimeType: file.type,
                            email: email || '',
                            userId: userId
                        },
                        i + 1
                    );
                }
                handleFinalSuccess();

            } catch (error) {
                showError(error.message);
            }
        }

        async function uploadChunkJson(payload, indexStr) {
            // ==========================================
            // [Fix] ç§»é™¤å¤šé¤˜çš„ { body: ... } åŒ…è£
            // ==========================================
            const response = await fetch(N8N_WEBHOOK_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload) // ä¿®æ­£è™•ï¼šç›´æ¥å‚³é€ payload
            });

            if (!response.ok) {
                const txt = await response.text();
                throw new Error(`åˆ†æ®µ ${indexStr} å¤±æ•—: ${response.status} ${txt}`);
            }
            debugLog(`âœ… åˆ†æ®µ ${indexStr} ä¸Šå‚³æˆåŠŸ`, 'success');
            await sleep(200);
        }

        // ==========================================
        // ğŸ¨ WAV ç·¨ç¢¼å‡½æ•¸ï¼ˆä¿ç•™ï¼‰
        // ==========================================
        
        function sliceAndEncodeWav(audioBuffer, startTime, endTime) {
            return new Promise((resolve) => {
                const sampleRate = audioBuffer.sampleRate;
                const startOffset = Math.floor(startTime * sampleRate);
                const endOffset = Math.floor(endTime * sampleRate);
                const frameCount = endOffset - startOffset;
                const channels = audioBuffer.numberOfChannels;

                const interleaved = new Float32Array(frameCount * channels);
                
                for (let channel = 0; channel < channels; channel++) {
                    const channelData = audioBuffer.getChannelData(channel).subarray(startOffset, endOffset);
                    for (let i = 0; i < frameCount; i++) {
                        interleaved[i * channels + channel] = channelData[i];
                    }
                }

                const buffer = new ArrayBuffer(44 + interleaved.length * 2);
                const view = new DataView(buffer);

                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + interleaved.length * 2, true);
                writeString(view, 8, 'WAVE');
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, channels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * channels * 2, true);
                view.setUint16(32, channels * 2, true);
                view.setUint16(34, 16, true);
                writeString(view, 36, 'data');
                view.setUint32(40, interleaved.length * 2, true);

                let offset = 44;
                for (let i = 0; i < interleaved.length; i++) {
                    let s = Math.max(-1, Math.min(1, interleaved[i]));
                    s = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    view.setInt16(offset, s, true);
                    offset += 2;
                }

                resolve(new Blob([view], { type: 'audio/wav' }));
            });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // ==========================================
        // ğŸ¯ ä¸»è¦äº‹ä»¶è™•ç†
        // ==========================================
        
        function debugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logDiv = document.getElementById('debugLog');
            const line = document.createElement('div');
            line.className = `debug-line ${type}`;
            line.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(line);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        async function initLiff() {
            try {
                debugLog('åˆå§‹åŒ– LIFF...', 'info');
                if(typeof liff !== 'undefined'){
                    await liff.init({ liffId: LIFF_ID });
                    if (!liff.isLoggedIn()) {
                        liff.login();
                    } else {
                        const user = await liff.getDecodedIDToken();
                        debugLog(`âœ… LIFF OK, user: ${user?.email || 'no email'}`, 'success');
                        if(user && user.email) {
                            document.getElementById('emailInput').value = user.email;
                        }
                    }
                }
            } catch (err) {
                debugLog(`âŒ LIFF Error: ${err.message}`, 'error');
            }
        }
        initLiff();

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const fileInfo = document.getElementById('fileInfo');
            
            if (file) {
                const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                const isAudio = file.type.startsWith('audio/') || file.name.endsWith('.m4a');
                
                fileInfo.textContent = `ğŸ“„ ${file.name} (${sizeMB} MB)`;
                fileInfo.style.display = 'block';
                fileInfo.classList.remove('large-file');
                
                debugLog(`æª”æ¡ˆåµæ¸¬: ${file.name}, ${sizeMB} MB, Type: ${file.type}`, 'info');
                
                if (isAudio) {
                    if (file.size <= GROQ_LIMIT) {
                        fileInfo.textContent += ` âœ… å°‡ä½¿ç”¨ JWT Token è½‰éŒ„`;
                        debugLog(`éŸ³è¨Š â‰¤ 25MBï¼Œå°‡ä½¿ç”¨ JWT Token ç›´æ¥è½‰éŒ„`, 'success');
                    } else {
                        fileInfo.classList.add('large-file');
                        const estimatedChunks = Math.ceil(file.size / (GROQ_LIMIT * 0.8));
                        fileInfo.textContent += ` âš ï¸ å°‡ä½¿ç”¨ JWT Token åˆ†æ®µè½‰éŒ„ (ç´„ ${estimatedChunks} æ®µ)`;
                        debugLog(`éŸ³è¨Š > 25MBï¼Œå°‡ä½¿ç”¨ JWT Token åˆ†æ®µè½‰éŒ„`, 'warn');
                    }
                } else if (file.size > LARGE_FILE_THRESHOLD) {
                    const chunks = Math.ceil(file.size / (10 * 1024 * 1024));
                    fileInfo.classList.add('large-file');
                    fileInfo.textContent += ` - å°‡åˆ†æˆ ${chunks} æ®µä¸Šå‚³`;
                    debugLog(`å¤§å‹æ–‡ä»¶ï¼Œå°‡åˆ†æˆ ${chunks} æ®µ`, 'warn');
                } else {
                    debugLog('æª”æ¡ˆå¤§å°é©ä¸­ï¼Œå°‡ç›´æ¥ä¸Šå‚³', 'success');
                }
            }
        });

        document.getElementById('uploadForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const file = document.getElementById('fileInput').files[0];
            const email = document.getElementById('emailInput').value.trim();

            if (!file) {
                alert('è«‹é¸æ“‡æª”æ¡ˆ'); return;
            }
            
            if (email && !email.includes('@')) {
                alert('è«‹è¼¸å…¥æœ‰æ•ˆçš„ Email æ ¼å¼'); return;
            }

            debugLog(`é–‹å§‹è™•ç†ä»»å‹™...`, 'info');
            if (!email) {
                debugLog('æœªå¡«å¯« Emailï¼Œçµæœå°‡é€é LINE é€šçŸ¥', 'info');
            }
            
            const isAudio = file.type.startsWith('audio/') || file.name.endsWith('.m4a');

            if (isAudio) {
                const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                
                // ğŸ”‘ å–å¾— JWT Token
                try {
                    await getTemporaryToken();
                } catch (error) {
                    showError('ç„¡æ³•å–å¾—è½‰éŒ„æˆæ¬Šï¼Œè«‹ç¨å¾Œå†è©¦');
                    return;
                }
                
                // è™•ç†éŸ³è¨Š
                if (file.size <= GROQ_LIMIT) {
                    debugLog(`ğŸµ éŸ³è¨Š ${sizeMB}MBï¼Œä½¿ç”¨ JWT Token ç›´æ¥è½‰éŒ„`, 'success');
                    await processSmallAudioWithJWT(file, email);
                } else {
                    debugLog(`ğŸµ éŸ³è¨Š ${sizeMB}MBï¼Œä½¿ç”¨ JWT Token åˆ†æ®µè½‰éŒ„`, 'warn');
                    await processLargeAudioWithJWT(file, email);
                }
            } else if (file.size > LARGE_FILE_THRESHOLD) {
                debugLog('å•Ÿå‹•äºŒé€²ä½åˆ†æ®µæµç¨‹', 'warn');
                uploadLargeFile(file, email);
            } else {
                debugLog('ä¸€èˆ¬æª”æ¡ˆç›´æ¥ä¸Šå‚³', 'info');
                uploadDirectly(file, email);
            }
        });

        // UI Helpers
        function setupUI(status) {
            const submitBtn = document.getElementById('submitBtn');
            const resultMsg = document.getElementById('resultMsg');
            const progressWrapper = document.getElementById('progressWrapper');
            const progressBar = document.getElementById('progressBar');
            const statusText = document.getElementById('statusText');

            submitBtn.disabled = true;
            submitBtn.textContent = "â³ è™•ç†ä¸­...";
            resultMsg.style.display = "none";
            progressWrapper.style.display = "block";
            progressBar.style.width = "0%";
            progressBar.classList.remove("processing");
            statusText.textContent = status;
        }

        function updateProgress(loaded, total, text) {
            const percent = Math.round((loaded / total) * 100);
            const progressBar = document.getElementById('progressBar');
            const statusText = document.getElementById('statusText');
            progressBar.style.width = percent + "%";
            statusText.textContent = `${text} ${percent}%`;
            if (percent === 100) {
                statusText.textContent = "ğŸ§  AI è™•ç†ä¸­...";
                progressBar.classList.add("processing");
            }
        }

        function handleXhrLoad(xhr) {
            debugLog(`å›æ‡‰: ${xhr.status}`, xhr.status === 200 ? 'success' : 'error');
            
            if (xhr.status === 200) {
                handleFinalSuccess(xhr.responseText);
            } else {
                showError(`HTTP ${xhr.status}: ${xhr.responseText}`);
            }
        }

        function handleFinalSuccess(responseText = "") {
            const submitBtn = document.getElementById('submitBtn');
            const closeBtn = document.getElementById('closeBtn');
            const resultMsg = document.getElementById('resultMsg');
            const statusText = document.getElementById('statusText');
            const progressBar = document.getElementById('progressBar');
            const email = document.getElementById('emailInput').value.trim();

            progressBar.style.width = "100%";
            progressBar.classList.add("processing");
            statusText.textContent = "âœ… å®Œæˆ";
            
            let msg = email 
                ? 'è™•ç†å®Œç•¢ï¼Œçµæœå·²ç™¼é€è‡³ Email' 
                : 'è™•ç†å®Œç•¢ï¼Œæ‘˜è¦å°‡é€é LINE é€šçŸ¥æ‚¨';
                
            try {
                if(responseText) {
                    const res = JSON.parse(responseText);
                    if(res.summary) msg = res.summary;
                }
            } catch(e) {}

            resultMsg.innerHTML = `<strong>âœ… ä»»å‹™å®Œæˆï¼</strong><br>${msg}`;
            resultMsg.className = "message-box success";
            resultMsg.style.display = "block";
            submitBtn.textContent = "å®Œæˆ";
            closeBtn.style.display = "block";
            debugLog('ğŸ‰ All Done.', 'success');
        }

        function showError(msg) {
            const submitBtn = document.getElementById('submitBtn');
            const closeBtn = document.getElementById('closeBtn');
            const resultMsg = document.getElementById('resultMsg');
            
            debugLog(`âŒ Error: ${msg}`, 'error');
            resultMsg.innerHTML = `âŒ ${msg}`;
            resultMsg.className = "message-box error";
            resultMsg.style.display = "block";
            submitBtn.disabled = false;
            submitBtn.textContent = "é‡è©¦";
            closeBtn.style.display = "block";
        }

        async function getUserId() {
            try {
                if (typeof liff !== 'undefined' && liff.isLoggedIn()) {
                    const profile = await liff.getProfile();
                    return profile.userId;
                }
            } catch (e) {}
            return '';
        }

        async function appendUserId(formData) {
            const uid = await getUserId();
            if(uid) formData.append('userId', uid);
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        debugLog('ğŸš€ System Ready: v5.2 JWT Token Mode (Fixed)', 'success');
    </script>
</body>
</html>
